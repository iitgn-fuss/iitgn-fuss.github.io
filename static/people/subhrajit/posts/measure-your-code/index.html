<!doctype html><html lang=en-us class=m-auto><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-TNCJNHYTX7"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TNCJNHYTX7")</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://iitgn-fuss.github.io/people/subhrajit/favicon.ico type=image/x-icon><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;400;500;600;700&display=swap"><link rel=stylesheet href=https://iitgn-fuss.github.io/people/subhrajit/main.min.a31612324a17cf3005c06b5e04fb80d58b21bc6861ae448473e7a997e80d9ec9.css integrity="sha256-oxYSMkoXzzAFwGteBPuA1YshvGhhrkSEc+epl+gNnsk=" crossorigin=anonymous><style>body,h1,h2,h3,h4,h5,h6,p,span,div,a,li,td,th,input,textarea,button,label,select{font-family:comfortaa,cursive!important}i.fas,i.far,i.fab,i.fal,i.fad,i.fa,i[class*=fa-],i.ai,i[class*=ai-],.fas::before,.far::before,.fab::before,.fal::before,.fad::before,.fa::before,[class*=fa-]::before,.ai::before,[class*=ai-]::before{font-family:"font awesome 5 free","font awesome 5 brands","font awesome 5 pro",academicons!important;font-weight:inherit!important}.fas,.fas::before{font-weight:900!important}.far,.far::before{font-weight:400!important}.fab,.fab::before{font-family:"font awesome 5 brands"!important;font-weight:400!important}html{touch-action:manipulation;scroll-behavior:smooth}.panel{max-height:0;transition:.3s ease-out}.profile-photo-container{img { max-width: 100%; }}.profile-section{padding:1rem}@media(max-width:1024px){.grid-cols-1.lg\\:grid-cols-5{gap:1rem!important}}@media(max-width:768px){body{padding:.5rem!important}.profile-section{padding:.5rem;text-align:center}.profile-section h1{font-size:1.4rem!important;line-height:1.3;margin-bottom:.5rem!important}.profile-section h2{font-size:1.2rem!important;line-height:1.3}.profile-section p{font-size:.85rem!important;line-height:1.4;margin-bottom:.3rem!important}.social-icons{justify-content:center;gap:1rem;flex-wrap:wrap}.accordion>p{padding:.75rem!important;font-size:.95rem!important}.panel{margin-left:.5rem!important;padding-left:.5rem!important;padding-right:.5rem!important}}@media(max-width:480px){body{padding:.25rem!important}.grid-cols-1.lg\\:grid-cols-5{gap:.5rem!important}.profile-section{padding:.25rem}.profile-section h1{font-size:1.3rem!important}.profile-section p{font-size:.8rem!important}.accordion>p{padding:.5rem!important;font-size:.9rem!important}.accordion>p i{font-size:.9rem!important}.social-icons a{padding:.4rem!important;font-size:1.1rem!important}}.pagefind-ui__search-input{color:#1e293b;width:100%;padding:.75em;border-radius:.75rem;border:2px solid #0ea5e9;background-color:#f8fafc;transition:all .2s ease;font-size:.95rem}.pagefind-ui__search-input:focus{outline:none;border-color:#0284c7;box-shadow:0 0 0 3px rgba(14,165,233,.1)}.pagefind-ui__search-clear{display:none}.dark .pagefind-ui__search-input{color:#f1f5f9;background-color:#334155;border-color:#22c55e;width:100%;padding:.75em;border-radius:.25em;border:1px solid gray}.dark .pagefind-ui__search-input::placeholder{color:#8f8f8f}.chevron{transition:300ms linear rotate}.active>.chevron{transform:rotate(90deg)}</style><script>const expandAccordion=e=>{const t=Array.from(document.querySelectorAll(".panel")),n=Array.from(document.querySelectorAll(".accordion"));if(!e.parentElement.classList.contains("active")){n.forEach(e=>{e.classList.remove("active")}),e.parentElement.classList.add("active"),t.forEach(function(e){e.style.maxHeight=null});let s=e.parentElement.nextElementSibling;if(s.id!="skill-panel"&&document.querySelector("#skill-panel")){let e=Array.from(document.querySelectorAll("#skill-percent"));e.forEach(e=>{e.style.width="0"})}s.style.maxHeight=s.scrollHeight+"px"}}</script><script>let html=document.querySelector("html"),theme=window.localStorage.getItem("theme");const setTheme=e=>{html.classList.remove("light"),e==="dark"?(html.classList.add("dark"),window.localStorage.setItem("theme","dark")):(html.classList.remove("dark"),window.localStorage.setItem("theme","light")),fixThemeToggleIcon(e)},fixThemeToggleIcon=e=>{let t=document.querySelector(".theme-toggle");t&&(e==="dark"?(t.classList.remove("fa-moon"),t.classList.add("fa-sun")):(t.classList.remove("fa-sun"),t.classList.add("fa-moon")))};if(theme==null)if(html.classList.contains("dark"))theme="dark";else if(html.classList.contains("light"))theme="light";else{const e=window.matchMedia("(prefers-color-scheme: dark)").matches;e?theme="dark":theme="light"}setTheme(theme);const toggleTheme=()=>{setTheme(html.classList.contains("dark")?"light":"dark")};window.onload=()=>{fixThemeToggleIcon(theme);let e=document.querySelector(".accordion.active");e&&(e.nextElementSibling.style.maxHeight=e.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let e=document.querySelector(".accordion.active");e&&(e.nextElementSibling.style.maxHeight=e.nextElementSibling.scrollHeight+"px")}</script></head><body class="h-screen p-2 px-4 sm:px-6 lg:px-8 xl:px-12 2xl:px-16 flex flex-col"><header class="nav sticky top-0 z-50 w-full"><div class="flex flex-row py-3 px-4 sm:px-6 bg-white/90 dark:bg-neutral-900/90 backdrop-blur-md justify-between items-center"><nav class="flex items-center gap-4"><a class="text-neutral-600 dark:text-neutral-300 text-sm hover:text-cyan-600 dark:hover:text-cyan-400 transition-colors no-underline hover:no-underline" href=https://iitgn-fuss.github.io/people/subhrajit/>Home</a><div class=relative id=cv-dropdown-container><button id=cv-btn class="text-neutral-600 dark:text-neutral-300 text-sm hover:text-cyan-600 dark:hover:text-cyan-400 transition-colors flex items-center gap-1 cursor-pointer">
CV ▾</button><div id=cv-menu class="hidden absolute left-0 top-full mt-2 z-50"><div class="bg-white dark:bg-neutral-800 rounded-lg shadow-lg border border-neutral-200 dark:border-neutral-700 py-1 min-w-[100px]"><a href=https://iitgn-fuss.github.io/people/subhrajit/files/resume_subhrajit.pdf class="block px-4 py-2 text-sm text-neutral-600 dark:text-neutral-300 hover:bg-cyan-50 dark:hover:bg-neutral-700 hover:text-cyan-600 dark:hover:text-cyan-400 no-underline hover:no-underline">Short</a>
<a href=https://iitgn-fuss.github.io/people/subhrajit/files/cv_subhrajit.pdf class="block px-4 py-2 text-sm text-neutral-600 dark:text-neutral-300 hover:bg-cyan-50 dark:hover:bg-neutral-700 hover:text-cyan-600 dark:hover:text-cyan-400 no-underline hover:no-underline">Long</a></div></div></div><a class="text-neutral-600 dark:text-neutral-300 text-sm hover:text-cyan-600 dark:hover:text-cyan-400 transition-colors no-underline hover:no-underline" href=https://iitgn-fuss.github.io/people/subhrajit/gallery/>Gallery</a>
<a class="text-cyan-600 dark:text-cyan-400 font-semibold text-sm hover:text-cyan-600 dark:hover:text-cyan-400 transition-colors no-underline hover:no-underline" href=https://iitgn-fuss.github.io/people/subhrajit/posts/>Posts</a></nav><div class="flex items-center gap-2"><div class=relative><button id=search-icon class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-neutral-100 dark:hover:bg-neutral-800 text-neutral-500 hover:text-cyan-600 dark:text-neutral-400 dark:hover:text-cyan-400 transition-all">
<i class="fas fa-search text-sm"></i>
</button>
<input id=search-input type=text placeholder=Search... class="hidden absolute right-0 top-10 w-48 sm:w-64 px-4 py-2 text-sm border border-neutral-200 dark:border-neutral-700 rounded-lg bg-white dark:bg-neutral-800 text-neutral-800 dark:text-neutral-100 shadow-lg focus:outline-none focus:ring-2 focus:ring-cyan-500"></div><button id=theme-btn class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-neutral-100 dark:hover:bg-neutral-800 text-neutral-500 hover:text-cyan-600 dark:text-neutral-400 dark:hover:text-cyan-400 transition-all">
<i class="fas fa-sun theme-toggle text-sm"></i></button></div></div><div style="height:2px;background:linear-gradient(to right,#22d3d1,#14b8a6,#10b981);margin-bottom:1rem"></div></header><script>(function(){var e,s,o,n=document.getElementById("cv-btn"),t=document.getElementById("cv-menu");n&&(n.onclick=function(e){e.preventDefault(),e.stopPropagation(),t.classList.contains("hidden")?t.classList.remove("hidden"):t.classList.add("hidden")}),document.onclick=function(e){t&&!n.contains(e.target)&&!t.contains(e.target)&&t.classList.add("hidden")},s=document.getElementById("search-icon"),e=document.getElementById("search-input"),s&&(s.onclick=function(){e.classList.contains("hidden")?(e.classList.remove("hidden"),e.focus()):e.classList.add("hidden")}),e&&(e.onblur=function(){setTimeout(function(){e.classList.add("hidden")},150)},e.onkeypress=function(t){if(t.key==="Enter"){var n=e.value.trim();n&&(window.location.href="/search?q="+encodeURIComponent(n))}}),o=document.getElementById("theme-btn"),o&&(o.onclick=function(){toggleTheme()})})()</script><main class="grow w-full"><div class="prose prose-neutral dark:prose-invert max-w-none prose-a:text-cyan-600 prose-a:dark:text-cyan-400 prose-a:font-medium"><div class=mb-4><h1 class="top-h1 text-neutral-900 dark:text-white">How to Measure Performance of Your Code</h1><p class="text-neutral-500 dark:text-neutral-400 text-sm mb-1">December 26, 2025</p></div><div class=content><p>Measuring code performance accurately is crucial, especially when optimizing the existing algorithms or designing new ones. In this post, I’ll share my learnings of measuring code performance using various tools and techniques.</p><p>For measuring execution time, we can use the following techniques:</p><ol><li>Wall Clock Time (<code>clock_gettime</code>)</li><li>Linux resource usage metrics (<code>getrusage</code>)</li></ol><p>To measure raw Time Stamp Counter (or, ticks), on x86 architectures we can use:</p><ol><li><code>RDTSC</code> (Read Time-Stamp Counter)</li></ol><p>Finally, to pinpoint performance bottlenecks, we can use the Linux <code>perf</code> tool; However, there are two ways to use it:</p><ol><li><code>perf</code> Command line tool</li><li><code>perf_event_open</code> syscall for custom profiling code segments.</li></ol><p>We will explore each of these methods in detail, with the help of an example C code snippet that we will measure using these techniques.
The naive function snippet we will use for measurement is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum_of_two_arrays</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>array1, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>array2, <span style=color:#66d9ef>int</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, sum2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sum1 <span style=color:#f92672>+=</span> array1[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sum2 <span style=color:#f92672>+=</span> array2[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    total_sum <span style=color:#f92672>=</span> sum1 <span style=color:#f92672>+</span> sum2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> total_sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=wall-clock-time-clock_gettime>Wall Clock Time (clock_gettime)</h2><p>The most popular way to measure code performance is by using wall clock time. The <a href=https://man7.org/linux/man-pages/man3/clock_gettime.3.html><code>clock_gettime</code></a> function in Linux provides wall-clock time measurements with nanosecond precision. It can be used to measure the elapsed time for a specific code segment. While there are multiple clock types available, <code>CLOCK_MONOTONIC</code> is generally preferred for measuring elapsed time as it is not affected by system time changes. To use <code>clock_gettime</code>, we have to include the <code>&lt;time.h></code> header file.</p><h3 id=usage>Usage</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Include necessary headers and define variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> timespec start, end;
</span></span><span style=display:flex><span><span style=color:#a6e22e>clock_gettime</span>(CLOCK_MONOTONIC, <span style=color:#f92672>&amp;</span>start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Code segment to measure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sum_of_two_arrays</span>(array1, array2, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>clock_gettime</span>(CLOCK_MONOTONIC, <span style=color:#f92672>&amp;</span>end);
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> seconds <span style=color:#f92672>=</span> end.tv_sec <span style=color:#f92672>-</span> start.tv_sec;
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> nanoseconds <span style=color:#f92672>=</span> end.tv_nsec <span style=color:#f92672>-</span> start.tv_nsec;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> elapsed <span style=color:#f92672>=</span> seconds <span style=color:#f92672>+</span> nanoseconds<span style=color:#f92672>*</span><span style=color:#ae81ff>1e-9</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Elapsed time: %.9f seconds</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, elapsed);
</span></span></code></pre></div><h3 id=output>Output</h3><pre tabindex=0><code>Elapsed time: XXX
</code></pre><h2 id=getrusage>getrusage</h2><p>In linux systems, <a href=https://www.man7.org/linux/man-pages/man2/getrusage.2.html><code>getrusage</code></a> is a system call that provides resource usage statistics for the calling process. It is used to measure the resources used by the process, like CPU time, memory usage, etc. We used this system call to measure the CPU time used by our code. POSIX.1 specifies <code>getrusage()</code>, but specifies only the fields <code>ru_utime</code> and <code>ru_stime</code>. And, for our benchmarking purposes, we can use <code>ru_utime</code> and <code>ru_stime</code> to measure the user CPU time and system CPU time, respectively.
The <code>getrusage</code> system call provides information about resource usage for a process, including user and system CPU time. The user CPU time represents the amount of CPU time spent in user mode, while the system CPU time represents the time spent in kernel mode. By measuring the user CPU time before and after executing a code segment, we can determine the CPU time consumed by that segment. To use <code>getrusage</code>, we need to include the <code>&lt;sys/resource.h></code> header file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Function to measure CPU time in microseconds as a long double
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>cputime</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rusage rus;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>getrusage</span>(RUSAGE_SELF, <span style=color:#f92672>&amp;</span>rus);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rus.ru_utime.tv_sec <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000000.0</span>L <span style=color:#f92672>+</span> rus.ru_utime.tv_usec;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=usage-1>Usage</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#75715e>// Include necessary headers and define variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> start_time, end_time, cpu_time_used;
</span></span><span style=display:flex><span>    start_time <span style=color:#f92672>=</span> <span style=color:#a6e22e>cputime</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Code segment to measure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sum_of_two_arrays</span>(array1, array2, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    end_time <span style=color:#f92672>=</span> <span style=color:#a6e22e>cputime</span>();
</span></span><span style=display:flex><span>    cpu_time_used <span style=color:#f92672>=</span> end_time <span style=color:#f92672>-</span> start_time;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;CPU time used: %.3Lf microseconds</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, cpu_time_used);
</span></span></code></pre></div><h2 id=rdtsc>RDTSC</h2><p>On the x86 architecture, the <code>RDTSC</code> (Read Time-Stamp Counter) instruction is a low-level way to measure the number of CPU ticks that have elapsed since the last reset. It provides a raw metric of code execution time, making it suitable for performance profiling. As <code>RDTSC</code> instruction measure the ticks that increments at a constant rate, regardless of CPU frequency scaling (e.g., Turbo Boost, power-saving states), the number of ticks per unit of real time will remain constant, even if the core&rsquo;s clock speed changes.
However, it is well-known that <code>RDTSC</code> does not provide accurate measurements in cases of code cross-contamination due to out-of-order execution. A white paper by Intel that explains how to measure ticks accurately using a combination of <code>CPUID</code>, <code>RDTSC</code>, and <code>RDTSCP</code> instructions. You can find the white paper here: <a href=https://cis.temple.edu/~qzeng/cis3207-spring18/files/ia-32-ia-64-benchmark-code-execution-paper.pdf>How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a>. <code>RDTSCP</code> mitigates some of the out-of-order execution issues by serializing the instruction stream before reading the time-stamp counter.
The reason of using <code>CPUID</code> instruction (which generates an interrupt) before and after <code>RDTSC</code>/<code>RDTSCP</code> is to serialize the instruction stream, ensuring that all previous instructions have completed before reading the time-stamp counter. This helps to get a more accurate measurement of the code segment.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>measure_rdtsc_start</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> cycles_low, cycles_high;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ticks;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>asm</span> <span style=color:#66d9ef>volatile</span>(<span style=color:#e6db74>&#34;CPUID</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;RDTSC</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;mov %%edx, %0</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;mov %%eax, %1</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=r&#34;</span>(cycles_high), <span style=color:#e6db74>&#34;=r&#34;</span>(cycles_low)<span style=color:#f92672>::</span><span style=color:#e6db74>&#34;%rax&#34;</span>, <span style=color:#e6db74>&#34;%rbx&#34;</span>, <span style=color:#e6db74>&#34;%rcx&#34;</span>, <span style=color:#e6db74>&#34;%rdx&#34;</span>);
</span></span><span style=display:flex><span>    ticks <span style=color:#f92672>=</span> (((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)cycles_high <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>|</span> cycles_low);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ticks;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Inline function for measuring rdtscp ticks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>measure_rdtscp_end</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> cycles_low, cycles_high;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ticks;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>asm</span> <span style=color:#66d9ef>volatile</span>(<span style=color:#e6db74>&#34;RDTSCP</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;mov %%edx, %0</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;mov %%eax, %1</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;CPUID</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=r&#34;</span>(cycles_high), <span style=color:#e6db74>&#34;=r&#34;</span>(cycles_low)<span style=color:#f92672>::</span><span style=color:#e6db74>&#34;%rax&#34;</span>,
</span></span><span style=display:flex><span>                               <span style=color:#e6db74>&#34;%rbx&#34;</span>, <span style=color:#e6db74>&#34;%rcx&#34;</span>, <span style=color:#e6db74>&#34;%rdx&#34;</span>);
</span></span><span style=display:flex><span>    ticks <span style=color:#f92672>=</span> (((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)cycles_high <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>|</span> cycles_low);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ticks;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=usage-2>Usage</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#75715e>// Include necessary headers and define variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> start_ticks, end_ticks, ticks_taken;
</span></span><span style=display:flex><span>    start_ticks <span style=color:#f92672>=</span> <span style=color:#a6e22e>measure_rdtsc_start</span>();
</span></span><span style=display:flex><span>    sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10000</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> <span style=color:#a6e22e>sum_of_two_arrays</span>(array1, array2, N);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    end_ticks <span style=color:#f92672>=</span> <span style=color:#a6e22e>measure_rdtscp_end</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ticks_taken <span style=color:#f92672>=</span> end_ticks <span style=color:#f92672>-</span> start_ticks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Ticks taken: %llu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ticks_taken);
</span></span></code></pre></div><h2 id=accuracy-considerations>Accuracy Considerations</h2><p>The actual elapsed time will vary based on system load and other factors like CPU frequency scaling, context switching, etc. To get more accurate measurements, consider measuring the code segment multiple times &mdash; create CDF plots to visualize the distribution of execution times or use statistical measures like 95% CI (Confidence Interval) mean to report the results. For execution time measurements, it&rsquo;s also important to minimize the impact of other processes running on the system. Running the measurements on a dedicated machine or using CPU affinity to bind the process to a specific core can help reduce variability.</p><p>I personally prefer averaging strategy of GMPBench to report the mean execution time of a given function. What it does is, it starts with a single iteration of the function and doubles the number of iterations until the total elapsed time exceeds a predefined threshold (e.g., 250 ms). Once the threshold is reached, it calculates the average time per iteration by dividing the total elapsed time by the number of iterations. This approach helps to ensure that the measurements are less affected by transient system load variations. Further, based on this computed mean time, it calculates throughput (operations per second) and reports that as the final performance metric.</p><p>Originally, GMPBench was designed to benchmark arbitrary-precision arithmetic operations in the GMP library, but the underlying methodology can be applied to measure the performance of any function or code segment.</p><p>Below you can find three different adapted macros of GMPBench style averaging strategy to measure execution time using <code>clock_gettime</code>, <code>RDTSC</code>, and <code>getrusage</code> respectively.</p><p>Whenever I report timing numbers, I prefer to run the GMPBench style averaging strategy for 20-30 times and report the 95% CI mean of the execution time or throughput numbers.</p><h2 id=linux-perf>Linux perf</h2><p>The &lsquo;perf&rsquo; tool in Linux is a powerful performance analysis tool that can measure various aspects of code performance, including CPU cycles, cache misses, and more. It provides a wealth of information but can be complex to use effectively.</p><p>In conclusion, accurately measuring code performance requires a combination of tools and techniques. By understanding the strengths and weaknesses of each method, you can gain valuable insights into your code&rsquo;s performance and identify areas for optimization.</p></div></div><div class="flex flex-row justify-around my-4"><h3 class="mb-1 mt-1 text-left mr-4"><i class="text-neutral-300 dark:text-neutral-600 fas fa-chevron-circle-left text-xl"></i></h3><h3 class="mb-1 mt-1 text-left ml-4"><i class="text-neutral-300 dark:text-neutral-600 fas fa-chevron-circle-right text-xl"></i></h3></div></main><footer class="text-xs text-center mt-6 py-4 text-neutral-400 dark:text-neutral-500"><p class=mb-0></p></footer></body></html>